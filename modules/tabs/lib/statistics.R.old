# ==============================================================================
# TURAS>TABS - STATISTICS MODULE
# ==============================================================================
# Purpose: Significance testing and statistical calculations
# Dependencies: banner_indices, cell_calculator, utilities
# Author: Turas Analytics Toolkit
# Version: 1.0.0
# ==============================================================================

# Constants
DEFAULT_ALPHA <- 0.05
DEFAULT_MIN_BASE <- 30
TOTAL_COLUMN <- "Total"
SIG_ROW_TYPE <- "Sig."

# ==============================================================================
# WEIGHTED VARIANCE
# ==============================================================================

#' Calculate Weighted Variance
#' 
#' Calculates POPULATION VARIANCE (not sample variance)
#' Used in t-tests for weighted means
#' 
#' @param values Numeric vector of values
#' @param weights Numeric vector of weights
#' @return Numeric weighted population variance
#' @export
weighted_variance <- function(values, weights) {
  
  # Remove NA and zero weights
  valid_idx <- !is.na(values) & !is.na(weights) & weights > 0
  values <- values[valid_idx]
  weights <- weights[valid_idx]
  
  if (length(values) < 2) return(0)
  
  sum_weights <- sum(weights)
  if (sum_weights == 0) return(0)
  
  # Calculate weighted mean
  weighted_mean <- sum(values * weights) / sum_weights
  
  # Calculate weighted variance
  weighted_var <- sum(weights * (values - weighted_mean)^2) / sum_weights
  
  return(weighted_var)
}

# ==============================================================================
# Z-TEST FOR PROPORTIONS
# ==============================================================================

#' Z-Test for Weighted Proportions
#' 
#' STATISTICAL METHODOLOGY:
#' - Uses pooled proportion: p_pooled = (count1 + count2) / (base1 + base2)
#' - For weighted data: Uses design-weighted counts and bases for pooled proportion
#' - Standard error uses effective-n (not weighted n) to account for design effect
#' - Two-tailed test (checks if proportions are different, not directional)
#' 
#' @param count1 Weighted count for group 1
#' @param base1 Weighted base for group 1
#' @param count2 Weighted count for group 2
#' @param base2 Weighted base for group 2
#' @param eff_n1 Effective sample size for group 1 (REQUIRED if is_weighted=TRUE)
#' @param eff_n2 Effective sample size for group 2 (REQUIRED if is_weighted=TRUE)
#' @param is_weighted Logical, whether data is weighted
#' @param min_base Minimum base size for testing
#' @param alpha Significance level (e.g., 0.05 for 95% CI)
#' @return List with $significant (logical), $p_value (numeric), $higher (logical)
#' @export
weighted_z_test_proportions <- function(count1, base1, count2, base2, 
                                       eff_n1 = NULL, eff_n2 = NULL,
                                       is_weighted = FALSE,
                                       min_base = DEFAULT_MIN_BASE,
                                       alpha = DEFAULT_ALPHA) {
  
  # Check for NA values
  if (any(is.na(c(count1, base1, count2, base2)))) {
    return(list(significant = FALSE, p_value = NA_real_, higher = FALSE))
  }
  
  # Check effective-n for weighted data
  if (is_weighted && (is.null(eff_n1) || is.null(eff_n2))) {
    warning("Weighted data requires effective-n for valid significance testing")
    return(list(significant = FALSE, p_value = NA_real_, higher = FALSE))
  }
  
  # Use effective-n for weighted data, actual base for unweighted
  n1 <- if (is_weighted && !is.null(eff_n1)) eff_n1 else base1
  n2 <- if (is_weighted && !is.null(eff_n2)) eff_n2 else base2
  
  # Check minimum base size
  if (n1 < min_base || n2 < min_base) {
    return(list(significant = FALSE, p_value = NA_real_, higher = FALSE))
  }
  
  # Check for zero bases
  if (base1 == 0 || base2 == 0) {
    return(list(significant = FALSE, p_value = NA_real_, higher = FALSE))
  }
  
  # Calculate proportions
  p1 <- count1 / base1
  p2 <- count2 / base2
  
  # Calculate pooled proportion
  p_pooled <- (count1 + count2) / (base1 + base2)
  
  # Handle edge cases
  if (p_pooled == 0 || p_pooled == 1) {
    return(list(significant = FALSE, p_value = 1, higher = (p1 > p2)))
  }
  
  # Calculate standard error
  se <- sqrt(p_pooled * (1 - p_pooled) * (1/n1 + 1/n2))
  
  if (se == 0 || is.na(se)) {
    return(list(significant = FALSE, p_value = 1, higher = (p1 > p2)))
  }
  
  # Calculate z-statistic
  z_stat <- (p1 - p2) / se
  
  # Calculate two-tailed p-value
  p_value <- 2 * pnorm(-abs(z_stat))
  
  return(list(
    significant = (!is.na(p_value) && p_value < alpha),
    p_value = p_value,
    higher = (p1 > p2)
  ))
}

# ==============================================================================
# T-TEST FOR MEANS
# ==============================================================================

#' T-Test for Weighted Means
#' 
#' Performs Welch's t-test for weighted means
#' Handles both weighted and unweighted data
#' 
#' @param values1 Numeric vector of values for group 1
#' @param values2 Numeric vector of values for group 2
#' @param weights1 Numeric vector of weights for group 1 (optional)
#' @param weights2 Numeric vector of weights for group 2 (optional)
#' @param min_base Minimum base size for testing
#' @param alpha Significance level
#' @return List with $significant (logical), $p_value (numeric), $higher (logical)
#' @export
weighted_t_test_means <- function(values1, values2, 
                                  weights1 = NULL, weights2 = NULL,
                                  min_base = DEFAULT_MIN_BASE,
                                  alpha = DEFAULT_ALPHA) {
  
  # Default to equal weights if not provided
  if (is.null(weights1)) weights1 <- rep(1, length(values1))
  if (is.null(weights2)) weights2 <- rep(1, length(values2))
  
  # Calculate effective sample sizes
  eff_n1 <- calculate_effective_base(weights1)
  eff_n2 <- calculate_effective_base(weights2)
  
  # Check minimum base size
  if (eff_n1 < min_base || eff_n2 < min_base) {
    return(list(significant = FALSE, p_value = NA_real_, higher = FALSE))
  }
  
  tryCatch({
    # Calculate weighted means
    mean1 <- weighted.mean(values1, weights1, na.rm = TRUE)
    mean2 <- weighted.mean(values2, weights2, na.rm = TRUE)
    
    if (is.na(mean1) || is.na(mean2)) {
      return(list(significant = FALSE, p_value = NA_real_, higher = FALSE))
    }
    
    # Calculate weighted variances
    var1 <- weighted_variance(values1, weights1)
    var2 <- weighted_variance(values2, weights2)
    
    # Calculate standard error
    se <- sqrt(var1/eff_n1 + var2/eff_n2)
    
    if (se == 0 || is.na(se)) {
      return(list(significant = FALSE, p_value = 1, higher = (mean1 > mean2)))
    }
    
    # Calculate t-statistic
    t_stat <- (mean1 - mean2) / se
    
    # Calculate degrees of freedom (Welch-Satterthwaite equation)
    df <- (var1/eff_n1 + var2/eff_n2)^2 / 
          ((var1/eff_n1)^2/(eff_n1-1) + (var2/eff_n2)^2/(eff_n2-1))
    
    if (is.na(df) || df <= 0) {
      return(list(significant = FALSE, p_value = NA_real_, higher = (mean1 > mean2)))
    }
    
    # Calculate two-tailed p-value
    p_value <- 2 * pt(-abs(t_stat), df)
    
    return(list(
      significant = (!is.na(p_value) && p_value < alpha),
      p_value = p_value,
      higher = (mean1 > mean2)
    ))
    
  }, error = function(e) {
    return(list(significant = FALSE, p_value = NA_real_, higher = FALSE))
  })
}

# ==============================================================================
# PAIRWISE SIGNIFICANCE TESTING
# ==============================================================================

#' Run Pairwise Significance Tests
#' 
#' Performs pairwise significance tests across all banner columns
#' Returns which columns each column is significantly higher than
#' 
#' @param row_data List of test data by column (each element has count, base, eff_n, etc.)
#' @param row_type Test type ("proportion", "topbox", "mean", "index")
#' @param banner_structure List with column_names and letters
#' @param alpha Significance level (p-value threshold)
#' @param bonferroni_correction Apply Bonferroni correction for multiple comparisons
#' @param min_base Minimum base size for testing
#' @param is_weighted Logical, whether data is weighted
#' @return List of significance letters for each column
#' @export
run_significance_tests_for_row <- function(row_data, row_type, banner_structure,
                                          alpha = DEFAULT_ALPHA,
                                          bonferroni_correction = TRUE,
                                          min_base = DEFAULT_MIN_BASE,
                                          is_weighted = FALSE) {
  
  # Validate inputs
  if (is.null(row_data) || length(row_data) == 0) return(list())
  if (is.null(banner_structure) || is.null(banner_structure$letters)) return(list())
  
  # Check that column names match
  if (!setequal(names(row_data), banner_structure$column_names)) {
    stop(sprintf(
      "Significance letter mapping mismatch:\n  Test data keys: %s\n  Banner columns: %s",
      paste(head(names(row_data), 5), collapse = ", "),
      paste(head(banner_structure$column_names, 5), collapse = ", ")
    ))
  }
  
  # Calculate number of comparisons
  num_comparisons <- choose(length(row_data), 2)
  if (num_comparisons == 0) return(list())
  
  # Apply Bonferroni correction if requested
  alpha_adj <- alpha
  if (bonferroni_correction && num_comparisons > 0) {
    alpha_adj <- alpha / num_comparisons
  }
  
  # Initialize results
  sig_results <- list()
  column_names <- names(row_data)
  
  # Test each column against all others
  for (i in seq_along(row_data)) {
    higher_than <- character(0)
    
    for (j in seq_along(row_data)) {
      if (i == j) next  # Skip self-comparison
      
      # Run appropriate test based on row type
      test_result <- if (row_type %in% c("proportion", "topbox")) {
        # Z-test for proportions
        weighted_z_test_proportions(
          row_data[[i]]$count, row_data[[i]]$base,
          row_data[[j]]$count, row_data[[j]]$base,
          row_data[[i]]$eff_n, row_data[[j]]$eff_n,
          is_weighted = is_weighted,
          min_base = min_base,
          alpha = alpha_adj
        )
      } else if (row_type %in% c("mean", "index")) {
        # T-test for means
        weighted_t_test_means(
          row_data[[i]]$values, row_data[[j]]$values,
          row_data[[i]]$weights, row_data[[j]]$weights,
          min_base = min_base,
          alpha = alpha_adj
        )
      } else {
        # Unknown type - no test
        list(significant = FALSE, p_value = NA_real_, higher = FALSE)
      }
      
      # If column i is significantly higher than column j
      if (test_result$significant && test_result$higher) {
        # Get letter for column j
        col_letter <- banner_structure$letters[
          banner_structure$column_names == column_names[j]
        ]
        if (length(col_letter) > 0) {
          higher_than <- c(higher_than, col_letter)
        }
      }
    }
    
    # Store results as concatenated letters (e.g., "ABC")
    sig_results[[column_names[i]]] <- paste(higher_than, collapse = "")
  }
  
  return(sig_results)
}

# ==============================================================================
# SIGNIFICANCE ROW CREATION
# ==============================================================================

#' Add Significance Row
#' 
#' Creates a significance row showing which columns are significantly different
#' Each cell shows letters indicating which other columns this column is higher than
#' 
#' @param test_data List of test data by column
#' @param banner_info Banner structure
#' @param row_type Test type ("proportion", "topbox", "mean", "index")
#' @param internal_columns Vector of all internal column keys
#' @param alpha Significance level
#' @param bonferroni_correction Apply Bonferroni correction
#' @param min_base Minimum base size
#' @param is_weighted Logical, whether data is weighted
#' @return Data frame with significance row or NULL
#' @export
add_significance_row <- function(test_data, banner_info, row_type, internal_columns,
                                alpha = DEFAULT_ALPHA,
                                bonferroni_correction = TRUE,
                                min_base = DEFAULT_MIN_BASE,
                                is_weighted = FALSE) {
  
  if (is.null(test_data) || length(test_data) < 2) return(NULL)
  
  # Initialize significance values
  sig_values <- setNames(rep("", length(internal_columns)), internal_columns)
  
  # Set Total column to "-" (not tested)
  total_key <- paste0("TOTAL::", TOTAL_COLUMN)
  if (total_key %in% names(sig_values)) {
    sig_values[total_key] <- "-"
  }
  
  # Test within each banner question
  for (banner_code in names(banner_info$banner_info)) {
    banner_cols <- banner_info$banner_info[[banner_code]]$internal_keys
    banner_test_data <- test_data[names(test_data) %in% banner_cols]
    
    # Only test if 2+ columns
    if (length(banner_test_data) > 1) {
      # Create banner structure for this banner
      banner_structure <- list(
        column_names = names(banner_test_data),
        letters = banner_info$banner_info[[banner_code]]$letters
      )
      
      # Run tests
      sig_results <- run_significance_tests_for_row(
        banner_test_data, 
        row_type, 
        banner_structure,
        alpha, 
        bonferroni_correction, 
        min_base,
        is_weighted = is_weighted
      )
      
      # Store results
      for (col_key in names(sig_results)) {
        sig_values[col_key] <- sig_results[[col_key]]
      }
    }
  }
  
  # Create significance row
  sig_row <- data.frame(
    RowLabel = "", 
    RowType = SIG_ROW_TYPE, 
    stringsAsFactors = FALSE
  )
  
  # Add significance letters for each column
  for (col_key in internal_columns) {
    sig_row[[col_key]] <- sig_values[col_key]
  }
  
  return(sig_row)
}

# ==============================================================================
# HELPER FUNCTIONS
# ==============================================================================

#' Prepare Test Data for Proportions
#' 
#' Prepares data structure needed for proportion testing
#' 
#' @param row_counts Named vector of counts
#' @param banner_bases List of base info
#' @param banner_row_indices List of row indices
#' @param master_weights Weight vector
#' @param internal_keys Column keys
#' @param is_weighted Logical
#' @return List of test data by column
#' @export
prepare_proportion_test_data <- function(row_counts, banner_bases, 
                                        banner_row_indices, master_weights,
                                        internal_keys, is_weighted) {
  
  test_data <- list()
  
  for (key in internal_keys) {
    row_idx <- banner_row_indices$row_indices[[key]]
    base_info <- banner_bases[[key]]
    
    test_data[[key]] <- list(
      count = row_counts[key],
      base = if (is_weighted) base_info$weighted else base_info$unweighted,
      eff_n = base_info$effective
    )
  }
  
  return(test_data)
}

#' Prepare Test Data for Means
#' 
#' Prepares data structure needed for mean testing
#' 
#' @param summary_stats List of summary statistics by column
#' @param internal_keys Column keys
#' @return List of test data by column
#' @export
prepare_mean_test_data <- function(summary_stats, internal_keys) {
  
  test_data <- list()
  
  for (key in internal_keys) {
    if (!is.null(summary_stats[[key]])) {
      test_data[[key]] <- list(
        values = summary_stats[[key]]$values,
        weights = summary_stats[[key]]$weights
      )
    }
  }
  
  return(test_data)
}

#' Validate Significance Test Inputs
#' 
#' Validates that inputs are appropriate for significance testing
#' 
#' @param test_data List of test data
#' @param row_type Test type
#' @return TRUE if valid, stops with error if not
#' @export
validate_sig_test_inputs <- function(test_data, row_type) {
  
  if (is.null(test_data) || !is.list(test_data)) {
    stop("test_data must be a list")
  }
  
  if (!row_type %in% c("proportion", "topbox", "mean", "index")) {
    stop(sprintf("Unknown row_type: %s", row_type))
  }
  
  # Check that each element has required fields
  for (key in names(test_data)) {
    data <- test_data[[key]]
    
    if (row_type %in% c("proportion", "topbox")) {
      required <- c("count", "base", "eff_n")
    } else {
      required <- c("values", "weights")
    }
    
    missing <- setdiff(required, names(data))
    if (length(missing) > 0) {
      stop(sprintf(
        "Test data for '%s' missing required fields: %s",
        key,
        paste(missing, collapse = ", ")
      ))
    }
  }
  
  return(TRUE)
}

# ==============================================================================
# MODULE METADATA
# ==============================================================================

#' Get Module Version
#' @export
get_statistics_version <- function() {
  return("1.0.0")
}

#' Get Module Info
#' @export
get_statistics_info <- function() {
  cat("")

  cat("================================================")

  cat("TURAS>TABS Statistics Module")

  cat("================================================")

  cat("Version:", get_statistics_version(), "")

  cat("Purpose: Significance testing and statistics")

  cat("")

  cat("Main Functions:")

  cat("  - weighted_variance()")

  cat("  - weighted_z_test_proportions()")

  cat("  - weighted_t_test_means()")

  cat("  - run_significance_tests_for_row()")

  cat("  - add_significance_row()")

  cat("  - prepare_proportion_test_data()")

  cat("  - prepare_mean_test_data()")

  cat("")

  cat("Statistical Methods:")

  cat("  - Z-tests for proportions (with pooling)")

  cat("  - T-tests for means (Welch's method)")

  cat("  - Bonferroni correction for multiple comparisons")

  cat("  - Effective-n adjustment for weighted data")

  cat("================================================\n")

}

# Module loaded message
cat("[OK] Turas>Tabs statistics module loaded")


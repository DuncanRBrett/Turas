Below are exact patch instructions you can hand to Opus. They’re written as a checklist with file paths, functions, and exact logic changes. The goal is a complete pass against your stated rules:* outcome type must be explicit and enforced* multinomial settings only required for multinomial* Driver_Settings required and consistent across templates/examples/docs* refusals must be controlled “REFUSED TO RUN” messages (not crash-looking stops)* no silent fallbacks* CatDriver should not “do continuous drivers” (you have a separate module)Patch Set A — Guard logic correctness (must-fix)A1) Fix multinomial settings being required for non-multinomial outcomesFile: catdriver/R/08a_guards_hard.RFunction: guard_outcome_levels_match() (or similarly named; the one currently checking config$multinomial_mode)ProblemIt currently validates multinomial settings even when outcome is ordinal/binary.PatchWrap multinomial-only checks:# BEFORE: multinomial_mode check happens unconditionally (remove this)# AFTER:if (config$outcome_type == "multinomial") {  if (is.null(config$multinomial_mode) || !nzchar(config$multinomial_mode)) {    catdriver_refuse(      code = "CFG_MULTINOMIAL_MODE_MISSING",      message = "Outcome type is multinomial but multinomial_mode is missing in config.",      fix = "Set multinomial_mode to 'per_outcome' or 'one_vs_all'."    )  }  if (config$multinomial_mode == "one_vs_all") {    if (is.null(config$target_outcome_level) || !nzchar(config$target_outcome_level)) {      catdriver_refuse(        code = "CFG_TARGET_OUTCOME_MISSING",        message = "multinomial_mode is 'one_vs_all' but target_outcome_level is missing.",        fix = "Set target_outcome_level to one of the declared outcome levels."      )    }  }}Acceptance test* With outcome_type = ordinal, the analysis must not require multinomial fields.* With outcome_type = multinomial, missing multinomial_mode must refuse cleanly.A2) Remove duplicate/contradictory multinomial guardsFiles: catdriver/R/08_guard.R and catdriver/R/08a_guards_hard.RYou likely have both:* guard_require_multinomial_mode() (conditional) ?* multinomial checks inside guard_outcome_levels_match() ?Patch* Keep multinomial checks in one place only (recommended: guard_require_multinomial_mode()).* Delete multinomial-specific checks from guard_outcome_levels_match() or ensure they are behind the if (outcome_type=="multinomial") guard (A1).Patch Set B — Refusal behaviour (no “crash vibe”)B1) Replace stop(...) in config/data mismatch paths with catdriver_refuse(...)Files:* catdriver/R/08a_guards_hard.R* catdriver/R/02_validation.R* any other guard/validation file where mismatches happenRule* Use catdriver_refuse(code=..., message=..., fix=...) for:o missing required config fieldso outcome mismatch with declared typeo missing driver settingso invalid referenceso multinomial underspecifiedo mapping failures* Use stop(...) only for actual internal bugs (e.g., “this should never happen”).Patch patternReplace:stop("=== CATDRIVER HARD ERROR === ...")with:catdriver_refuse(  code = "SOME_CODE",  message = "Human readable explanation.",  fix = "Exact action to take.")Acceptance criteria* When config is wrong, output should display a clear refusal header such as:“REFUSED TO RUN – CONFIG/DATA MISMATCH”* No stack trace-like output for refusals.B2) Ensure top-level runner catches refusals and prints cleanlyFile: catdriver/R/00_main.RFunction: run_categorical_keydriver() (or your top entry)PatchWrap full run in:with_refusal_handler({  # entire pipeline here})and ensure with_refusal_handler() prints:* refusal code* message* fix steps…and returns a structured refusal object (optional), not NULL.Patch Set C — Driver_Settings is required and consistent everywhereC1) Make Driver_Settings truly required and update example configFile: catdriver/examples/basic/catdriver_config.xlsx (or wherever the example lives)PatchAdd sheet: Driver_Settings with at least columns:* driver (string; must match Variables list)* type (categorical | ordinal | continuous | control_only)* levels_order (optional; comma-separated)* reference_level (optional)* missing_strategy (default: missing_as_level for categorical/ordinal drivers)* warn_n (default from Settings)* collapse_n (default from Settings)* collapse_label (default: Other)Populate for your example drivers, e.g.:* grade: categorical, ref=D* campus: categorical, ref=Cape Town* course_type: categorical, ref=Short* employment_field: categorical, ref=Finance* years_experience: control_only (see Patch Set E)Acceptance criteria* The example config must run without refusal (assuming dataset present).C2) Update config loader to validate Driver_Settings contentFile: catdriver/R/01_config.RPatchAfter reading Driver_Settings:* validate that every driver in Variables marked as “driver” exists in Driver_Settings* validate allowed types* validate reference_level exists among observed levels (if provided)* validate levels_order values exist in data (when applied later)Refuse (not stop) if missing.Patch Set D — Apply Driver_Settings in preprocessing (no hidden inference)D1) Preprocessing must respect driver types explicitlyFile: catdriver/R/03_preprocessing.RFunction(s): prepare_predictors() / detect_predictor_type() / similarPatch* Remove or demote inference rules (unique-count heuristics).* For each driver var:o read type from config$driver_settingso apply coercion:* categorical: factor (unordered), treatment contrasts* ordinal: ordered factor using levels_order (required for ordinal)* control_only: exclude from driver outputs but keep in model if allowed* continuous: do not allow as driver (see Patch Set E)If driver type missing:* refuse with: CFG_DRIVER_TYPE_MISSING and tell user to fill Driver_Settings.Acceptance criteria* No driver should be typed implicitly if Driver_Settings is required.D2) Reference levels must be enforcedFile: catdriver/R/03_preprocessing.RPatchFor categorical/ordinal predictors:* If reference_level set: relevel(x, ref=reference_level)* Else use default rule: most frequent non-missing level* Refuse if reference resolves to Missing (unless explicitly allowed).Patch Set E — Clarify “drivers vs controls”; disallow continuous driversE1) Add control_vars and forbid continuous in driver_varsFile: catdriver/R/01_config.R and config schemaPatch* In Variables sheet (or Settings), introduce a role column:o driver | control | ignore* Or, if you already have a role flag, enforce it.* Update pipeline:o driver_vars used for importance/patterns reportingo control_vars included in model formula but excluded from driver reportingEnforced ruleIf a variable is in driver_vars and driver_settings$type == continuous:* refuse: CFG_CONTINUOUS_DRIVER_NOT_ALLOWED* fix: “Move this to control role or use the continuous driver module.”Acceptance criteria* years_experience in your example becomes control (or control_only)Patch Set F — Missing data policy must be applied, not just implementedF1) Mandatory missing-handling step early in the pipelineFile: catdriver/R/00_main.RPipeline order (must be this order):1. load config2. load data3. guards on config structure (not data-dependent)4. compute missing summary (pre)5. apply missing strategies (R/10_missing.R)o drop missing outcome rowso drivers: missing_as_level by default6. compute missing summary (post)7. validate analysable N (based on post-missing)8. preprocessing (coercions, reference, collapsing)9. fit model10. mapping (must succeed)11. outputsAcceptance criteria* No complete.cases() gating before missing strategies run.* Output diagnostics show pre/post missing counts.F2) Replace complete-case validation with strategy-aware validationFile: catdriver/R/02_validation.RPatchRemove “complete-case N” as a required threshold.Instead use:* n_outcome_nonmissing (pre-missing stage)* n_after_missing_handling (post strategy)* n_effective_model (after preprocessing)Refuse if too small, but don’t demand complete cases across all vars.Patch Set G — Remove any legacy OR extraction fallback (no silent degradation)G1) Mapping must succeed or refuseFile: catdriver/R/05_importance.R and catdriver/R/00_main.RPatch* Delete substring-based extraction functions (or keep only for dev but never callable).* In main pipeline:o mapping <- map_terms_to_levels(...)o validate_mapping(mapping, ...)o if validation fails ? catdriver_refuse(CFG_MAPPING_FAILED, ...)Acceptance criteria* There is no code path that produces OR tables without the mapper.Patch Set H — Regression tests as hard gatesH1) Add “golden ordinal” test (must pass)File: tests/testthat/test_golden_ordinal.RAssertions (based on your fixture):* Outcome = Low < Neutral < High* Online OR < 1 (within a broad tolerance, e.g. OR < 0.9)* Grade A OR > Grade C OR > 1* Missing driver levels exist as “Missing / Not answered” where applicable* Refusal triggers are not thrown when config correctH2) Add “multinomial refusal” tests* If outcome_type multinomial and multinomial_mode missing ? refusal code CFG_MULTINOMIAL_MODE_MISSING* If mode one_vs_all and target missing ? refusal code CFG_TARGET_OUTCOME_MISSINGH3) Add “continuous driver not allowed” test* If driver_settings marks a driver as continuous and role=driver ? refusal code CFG_CONTINUOUS_DRIVER_NOT_ALLOWEDH4) Add “messy label mapping” test* Include a factor with spaces/punctuation and assert mapping covers all levels and ORs are produced.Final sign-off checklist (what “complete pass” means)Opus should not claim “done” until these are true:* ? Example config in zip runs without refusal* ? Multinomial settings only enforced for multinomial outcomes* ? Driver_Settings required and actually governs preprocessing* ? Missing policy applied before validation and modeling* ? No substring parsing remains reachable* ? Continuous drivers refused with guidance* ? Refusals use catdriver_refuse and are printed cleanly* ? Golden tests exist and cover the critical behavioursIf you want, paste Opus’s patch output (or re-upload the updated zip) and I’ll re-review strictly against this checklist and give you a clear PASS / FAIL.
Understood — and that changes the bar in an important way:If Turas modules are launched from the Turas GUI ? module GUI, then “console output” can’t mean “RStudio console”. It must mean: the module GUI must surface all INFO/WARN/REFUSE/ERROR messages in its own log panel.So, to be truly compliant with your “no silent fails” spec, you need one plumbing layer that guarantees:* anything written with cat() / message() shows up in the GUI log* any warning() shows up in the GUI log (not just as an R warning)* any turas_refuse() shows up in the GUI log in the same formatted refusal block* unexpected errors show up in the GUI log (same as your BUG_INTERNAL_ERROR block)* at the end: a definitive PASS / PASS_WITH_WARNINGS / REFUSED / FAILED summary is shown in the GUIBelow is the pattern I recommend (world-class, low-risk, and hard to regress).The core idea: a GUI log “sink” + condition handlers1) Implement a single logger function used everywhereIn shared/ create something like:turas_log <- function(level = c("INFO","WARN","ERROR"), msg) {  level <- match.arg(level)  line <- sprintf("[%s] %s", level, msg)  # Always print (for CLI runs)  cat(line, "\n")  # If running inside GUI, also push to GUI log sink  if (exists(".turas_gui_log_append", envir = .GlobalEnv, inherits = FALSE)) {    get(".turas_gui_log_append", envir = .GlobalEnv)(line)  }}Now you have a single “truth”:* in GUI mode, it appears in the module GUI log* in non-GUI mode, it prints to console2) Make warnings and errors impossible to missWrap your module run in:* withCallingHandlers() to intercept warnings and forward them into the GUI log* tryCatch() for unexpected errors* your existing with_refusal_handler() for refusalsSkeleton:run_module_with_gui_logging <- function(expr) {  warnings_seen <- character(0)  withCallingHandlers(    tryCatch(      with_refusal_handler(expr),      error = function(e) {        turas_log("ERROR", paste("BUG_INTERNAL_ERROR:", conditionMessage(e)))        stop(e) # or return failure object      }    ),    warning = function(w) {      msg <- conditionMessage(w)      warnings_seen <<- c(warnings_seen, msg)      turas_log("WARN", msg)      invokeRestart("muffleWarning")    },    message = function(m) {      turas_log("INFO", conditionMessage(m))      invokeRestart("muffleMessage")    }  )}Result: even if some developer forgets to cat("[WARN]"), any warning() still gets shown in the module GUI log.This is the “belt + braces” you want.GUI side: how to get the log into the module GUIIf your module GUI is Shiny (very likely), do this:3) A log buffer reactive + append functionInside server:log_buf <- shiny::reactiveVal(character(0))append_log <- function(line) {  log_buf(c(log_buf(), line))}assign(".turas_gui_log_append", append_log, envir = .GlobalEnv)onStop(function() rm(".turas_gui_log_append", envir = .GlobalEnv))Then render:* a scrolling text area (verbatimTextOutput) or custom HTML div.output$run_log <- shiny::renderText(paste(log_buf(), collapse = "\n"))4) Ensure cat() output also appearsIf your modules still use lots of cat(), you have two options:* Best: gradually replace cat() calls with turas_log("INFO", ...) / turas_log("WARN", ...).* Also good: during a run, temporarily sink() output to a connection that writes into append_log. (More brittle, but workable.)I’d do the best option: standardize on turas_log() going forward.What this means for “bulletproof”After you implement the above plumbing, your “no silent fails” guarantee becomes enforceable:* even optional-component failures (VIF, SHAP plots, etc.) will appear in the GUI log* hard refusals appear in the GUI log* unexpected errors appear in the GUI log* you can add a final status banner in the GUI (green/yellow/red)Without this, you’re still vulnerable to a “silent” failure from the user’s perspective even if you print to R console—because the user may never see that console.One more must-have: end-of-run summary in the GUIAt the end of each run, show something like:* PASS* PASS_WITH_WARNINGS (and list warning codes)* REFUSED: <reason_code>* FAILED: BUG_INTERNAL_ERRORYou can implement that as:* a status object returned from the module runner (preferred)* plus a final turas_log() summary lineQuick checkIf you tell me what GUI tech you’re using (Shiny vs something else), I’ll give you the exact drop-in shared/gui_logging.R file plus a minimal UI snippet for the module log panel.But even without that detail, the key principle stands:“Console output must appear in the module GUI” = you need a central logger + condition handlers, not just scattered cat() calls.Perfect — then you can make this rock solid with a small Shiny log “console” that captures:* turas_log() calls (preferred)* base cat() / message() output (via sink())* warning() (via withCallingHandlers())* refusals + unexpected errors (via your TRS wrapper)Below is a drop-in implementation you can add to shared/ and use from any module server.1) Add this file: shared/gui/gui_log.R# shared/gui/gui_log.R# ------------------------------------------------------------------------------# Shiny GUI logging for Turas# Captures:#   - turas_log() lines (direct)#   - cat()/print output (via sink)#   - warnings (via withCallingHandlers)#   - refusals/errors (via existing TRS wrappers + tryCatch)## Usage in a module Shiny server:#   log <- turas_gui_log_init(session)#   turas_gui_run_with_logging(log, { your_module_run() })#   output$run_log <- renderText(log$text())# ------------------------------------------------------------------------------turas_gui_log_init <- function(session = NULL, max_lines = 4000L) {  stopifnot(is.numeric(max_lines), length(max_lines) == 1, max_lines > 100)  rv <- shiny::reactiveValues(lines = character(0))  append <- function(x) {    if (length(x) == 0) return(invisible(NULL))    x <- as.character(x)    # Split any embedded newlines into separate lines    x <- unlist(strsplit(x, "\n", fixed = TRUE), use.names = FALSE)    # Drop empty trailing lines    if (length(x) && all(nchar(tail(x, 1)) == 0)) x <- x[nchar(x) > 0]    rv$lines <- c(rv$lines, x)    if (length(rv$lines) > max_lines) {      rv$lines <- tail(rv$lines, max_lines)    }    invisible(NULL)  }  text <- function() paste(rv$lines, collapse = "\n")  list(    append = append,    text = shiny::reactive(text()),    clear = function() { rv$lines <- character(0); invisible(NULL) }  )}# Preferred structured logging call used across modules:turas_log <- function(log = NULL, level = c("INFO","WARN","ERROR"), msg) {  level <- match.arg(level)  line <- sprintf("[%s] %s", level, msg)  # Always print for CLI/terminal runs  cat(line, "\n")  # Push into GUI log if provided  if (!is.null(log) && is.function(log$append)) {    log$append(line)  }  invisible(NULL)}# Internal: a text connection that forwards writes to log$append()turas_gui_text_connection <- function(log) {  textConnection(    ".__turas_gui_sink_buf",    open = "w",    local = TRUE  ) |> (\(con) {    # Wrap sink target so that on close we flush buffer into log    structure(con, class = c("turas_gui_sink_con", class(con)), log = log)  })()}# Close method to flush buffer if someone closes explicitlyclose.turas_gui_sink_con <- function(con, ...) {  log <- attr(con, "log")  buf <- get(".__turas_gui_sink_buf", envir = environment(con), inherits = FALSE)  if (!is.null(log) && is.function(log$append) && length(buf)) log$append(buf)  base::close(con, ...)}# Run an expression capturing warnings/messages/cat into GUI log + ensuring# a deterministic final status result.turas_gui_run_with_logging <- function(log, expr) {  stopifnot(!is.null(log), is.function(log$append))  # Capture stdout (cat/print) and messages  # Note: messages need sink(type="message") separately  sink_con_out <- textConnection(".__turas_out_buf", open = "w", local = TRUE)  sink_con_msg <- textConnection(".__turas_msg_buf", open = "w", local = TRUE)  # Ensure sinks are always released  on.exit({    # Flush buffers    out_buf <- get(".__turas_out_buf", envir = environment(sink_con_out), inherits = FALSE)    msg_buf <- get(".__turas_msg_buf", envir = environment(sink_con_msg), inherits = FALSE)    if (length(out_buf)) log$append(out_buf)    if (length(msg_buf)) log$append(paste0("[INFO] ", msg_buf))    # Unsink safely    while (sink.number(type = "output") > 0) sink(NULL, type = "output")    while (sink.number(type = "message") > 0) sink(NULL, type = "message")    close(sink_con_out)    close(sink_con_msg)  }, add = TRUE)  sink(sink_con_out, type = "output")  sink(sink_con_msg, type = "message")  warnings_seen <- character(0)  # A structured outcome you can use to set a GUI status badge  result <- withCallingHandlers(    tryCatch(      {        # If your shared layer provides with_refusal_handler(), use it here:        if (exists("with_refusal_handler", mode = "function")) {          with_refusal_handler(expr)        } else {          force(expr)        }      },      error = function(e) {        turas_log(log, "ERROR", paste("BUG_INTERNAL_ERROR:", conditionMessage(e)))        structure(          list(status = "FAILED", error = conditionMessage(e), warnings = warnings_seen),          class = "turas_run_result"        )      }    ),    warning = function(w) {      msg <- conditionMessage(w)      warnings_seen <<- c(warnings_seen, msg)      turas_log(log, "WARN", msg)      invokeRestart("muffleWarning")    },    message = function(m) {      turas_log(log, "INFO", conditionMessage(m))      invokeRestart("muffleMessage")    }  )  # If expression returned a turas_run_result already, keep it; else wrap success.  if (inherits(result, "turas_run_result")) {    return(result)  }  status <- if (length(warnings_seen)) "PASS_WITH_WARNINGS" else "PASS"  structure(    list(status = status, value = result, warnings = warnings_seen),    class = "turas_run_result"  )}2) Add a log panel in each module UIMinimal UI element:verbatimTextOutput("run_log")Optionally wrap in a scroll box:div(  style = "height: 320px; overflow-y: auto; background: #111; color: #eee; padding: 10px; border-radius: 6px;",  verbatimTextOutput("run_log"))3) Use it in your module serverExample skeleton:server <- function(input, output, session) {  log <- turas_gui_log_init(session)  output$run_log <- shiny::renderText({    log$text()  })  observeEvent(input$run_btn, {    log$clear()    turas_log(log, "INFO", "Starting analysis...")    res <- turas_gui_run_with_logging(log, {      # call your module’s main runner here      # e.g., keydriver_run(project_root, config_path, ...)      keydriver_main(...)    })    # Optional: show a badge / status line    turas_log(log, "INFO", paste("Run status:", res$status))  })}4) Why this meets your requirement* Anything printed with cat() or message() is captured via sink() and appears in the GUI log.* Any warning() is intercepted and forced into the GUI log (and muffled so it doesn’t clutter elsewhere).* Any unexpected error() becomes a GUI-visible [ERROR] BUG_INTERNAL_ERROR: ....* You can always show a final PASS / PASS_WITH_WARNINGS / FAILED.One strong recommendationNow that you have turas_log(log, ...), start migrating modules away from raw cat() for human-facing lines and use turas_log() instead. Raw cat() is still captured, but structured logs are cleaner and easier to test.If you tell me where your “launcher GUI” stores the module server calls (file path / naming convention), I’ll tailor the integration so you don’t have to copy/paste this into every module — you can centralize it once in shared and call it consistently.
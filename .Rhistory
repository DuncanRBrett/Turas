if(nrow(significant_results) > 0) {
cat("\nâœ… Found", nrow(significant_results), "questions with significant year-over-year changes")
improved <- sum(significant_results$Difference > 0, na.rm = TRUE)
declined <- sum(significant_results$Difference < 0, na.rm = TRUE)
cat("\nðŸ“ˆ Improved areas:", improved)
cat("\nðŸ“‰ Declined areas:", declined)
} else {
cat("\nâœ… Engagement levels remained stable between 2023 and 2024")
cat("\nðŸ“Š No statistically significant changes detected")
}
if(nrow(significant_results) > 0) {
cat("\nâœ… Found", nrow(significant_results), "questions with significant year-over-year changes")
improved <- sum(significant_results$Difference > 0, na.rm = TRUE)
declined <- sum(significant_results$Difference < 0, na.rm = TRUE)
cat("\nðŸ“ˆ Improved areas:", improved)
cat("\nðŸ“‰ Declined areas:", declined)
} else {
cat("\nâœ… Engagement levels remained stable between 2023 and 2024")
cat("\nðŸ“Š No statistically significant changes detected")
}
cat("\nðŸ“‰ Declined areas:", declined)
cat("Script completed at", as.character(Sys.time()), "\n")
SCRIPT_VERSION <- "7"
metadata_file <- "/Users/duncan/Library/CloudStorage/OneDrive-Personal/DB Files/2025 Projects/Crosstabs/Crosstab_Code_Sheet_Sample.xlsx"
TOTAL_COLUMN <- "Total"
SIG_ROW_TYPE <- "Sig Higher."
BASE_ROW_LABEL <- "Base (n=)"
FREQUENCY_ROW_TYPE <- "Frequency"
COLUMN_PCT_ROW_TYPE <- "Column %"
ROW_PCT_ROW_TYPE <- "Row %"
AVERAGE_ROW_TYPE <- "Average"
SCORE_ROW_TYPE <- "Score"
required_packages <- c("readxl", "dplyr", "tidyr", "openxlsx")
cat("Loading required packages...\n")
missing_packages <- setdiff(required_packages, rownames(installed.packages()))
if (length(missing_packages) > 0) {
stop("Missing required packages: ", paste(missing_packages, collapse = ", "),
"\nInstall with: install.packages(c('", paste(missing_packages, collapse = "', '"), "'))")
}
for (pkg in required_packages) {
library(pkg, character.only = TRUE, quietly = TRUE)
}
if (!file.exists(metadata_file)) {
stop("Metadata file not found: ", metadata_file)
}
cat("âœ“ Using metadata file:", basename(metadata_file), "\n")
cat("Loading project configuration...\n")
config_df <- read_excel(metadata_file, sheet = "Config")
if (!all(c("Setting", "Value") %in% names(config_df))) {
stop("Config sheet must have 'Setting' and 'Value' columns")
}
get_config <- function(setting_name, default_value = NULL) {
value <- config_df$Value[config_df$Setting == setting_name]
if (length(value) == 0 || is.na(value)) {
if (!is.null(default_value)) return(default_value)
stop("Required setting '", setting_name, "' not found in Config sheet")
}
return(value)
}
project_name <- get_config("project_name")
data_file <- get_config("data_file_path")
output_folder <- get_config("output_folder")
output_filename <- get_config("output_filename")
decimal_separator <- get_config("decimal_separator", ",")
show_frequency <- as.logical(get_config("show_frequency", "TRUE"))
show_percent_column <- as.logical(get_config("show_percent_column", "TRUE"))
show_percent_row <- as.logical(get_config("show_percent_row", "FALSE"))
boxcategory_frequency <- as.logical(get_config("boxcategory_frequency", "FALSE"))
boxcategory_percent_column <- as.logical(get_config("boxcategory_percent_column", "TRUE"))
boxcategory_percent_row <- as.logical(get_config("boxcategory_percent_row", "FALSE"))
decimal_places_percent <- as.numeric(get_config("decimal_places_percent", "0"))
decimal_places_ratings <- as.numeric(get_config("decimal_places_ratings", "1"))
decimal_places_index <- as.numeric(get_config("decimal_places_index", "1"))
enable_significance_testing <- toupper(get_config("enable_significance_testing", "FALSE")) == "TRUE"
significance_test_proportions <- toupper(get_config("significance_test_proportions", "TRUE")) == "TRUE"
significance_test_means <- toupper(get_config("significance_test_means", "TRUE")) == "TRUE"
significance_test_topbox <- toupper(get_config("significance_test_topbox", "TRUE")) == "TRUE"
significance_test_index <- toupper(get_config("significance_test_index", "TRUE")) == "TRUE"
significance_level <- as.numeric(get_config("significance_level", "0.95"))
significance_min_base <- as.numeric(get_config("significance_min_base", "30"))
bonferroni_correction <- toupper(get_config("bonferroni_correction", "TRUE")) == "TRUE"
if (significance_level <= 0 || significance_level >= 1) {
stop("significance_level must be between 0 and 1 (got: ", significance_level, ")")
}
if (significance_min_base < 1) {
stop("significance_min_base must be positive (got: ", significance_min_base, ")")
}
if (decimal_places_percent < 0 || decimal_places_ratings < 0 || decimal_places_index < 0) {
stop("Decimal places settings must be non-negative")
}
cat("âœ“ Project:", project_name, "\n")
cat("âœ“ Significance testing:", ifelse(enable_significance_testing, "ENABLED", "disabled"), "\n")
if (!file.exists(data_file)) stop("Data file not found: ", data_file)
if (!dir.exists(output_folder)) {
dir.create(output_folder, recursive = TRUE)
cat("âœ“ Created output folder:", output_folder, "\n")
}
error_log <- data.frame(
Timestamp = character(), Component = character(), Issue_Type = character(),
Description = character(), QuestionCode = character(), Severity = character(),
stringsAsFactors = FALSE
)
log_issue <- function(component, issue_type, description, question_code = "", severity = "Warning") {
error_log <<- rbind(error_log, data.frame(
Timestamp = as.character(Sys.time()), Component = component,
Issue_Type = issue_type, Description = description,
QuestionCode = question_code, Severity = severity,
stringsAsFactors = FALSE
))
}
cat("Loading survey data and metadata...\n")
questions_df <- read_excel(metadata_file, sheet = "Questions")
options_df <- read_excel(metadata_file, sheet = "Options")
survey_data <- read_excel(data_file)
questions_df$Create_Index[is.na(questions_df$Create_Index)] <- "N"
questions_df$Show_in_Crosstab[is.na(questions_df$Show_in_Crosstab)] <- "N"
questions_df$Use_As_Banner[is.na(questions_df$Use_As_Banner)] <- "N"
options_df$Show_In_Output[is.na(options_df$Show_In_Output)] <- "Y"
options_df$Exclude_From_Index[is.na(options_df$Exclude_From_Index)] <- "N"
cat("âœ“ Data loaded:", nrow(survey_data), "responses,",
nrow(questions_df), "questions,", nrow(options_df), "options\n")
safe_equal <- function(a, b) {
if (length(a) == 0 || length(b) == 0) return(logical(0))
trimws(as.character(a)) == trimws(as.character(b))
}
has_data <- function(df) {
!is.null(df) && is.data.frame(df) && nrow(df) > 0
}
get_valid_base <- function(data_subset, question_info) {
if (!has_data(data_subset)) return(0L)
question_code <- question_info$QuestionCode
if (question_info$Variable_Type == "Multi_Mention") {
num_columns <- suppressWarnings(as.numeric(question_info$Columns))
if (is.na(num_columns) || num_columns < 1) return(0L)
question_cols <- paste0(question_code, "_", seq_len(num_columns))
existing_cols <- question_cols[question_cols %in% names(data_subset)]
if (!length(existing_cols)) return(0L)
has_any_response <- Reduce("|", lapply(existing_cols, function(col) {
col_values <- data_subset[[col]]
!is.na(col_values) & col_values != "" & col_values != " "
}))
return(sum(has_any_response, na.rm = TRUE))
} else {
if (!question_code %in% names(data_subset)) return(0L)
col_values <- data_subset[[question_code]]
return(sum(!is.na(col_values) & col_values != "" & col_values != " ", na.rm = TRUE))
}
}
apply_base_filter <- function(data, filter_condition) {
if (is.na(filter_condition) || is.null(filter_condition) || filter_condition == "") {
result <- data
result$.original_row <- seq_len(nrow(data))
return(result)
}
if (grepl("[^A-Za-z0-9_$.()&|!<>= \\-+*/,'\"\\[\\]]", filter_condition)) {
log_issue("Filter", "Unsafe Characters",
paste("Rejected potentially unsafe filter:", filter_condition), "", "Warning")
result <- data
result$.original_row <- seq_len(nrow(data))
return(result)
}
tryCatch({
filter_result <- eval(parse(text = filter_condition), envir = data)
if (!is.logical(filter_result)) stop("Filter condition did not return logical vector")
# FIX #2: Validate filter length to prevent recycling
if (length(filter_result) != nrow(data)) {
log_issue("Filter", "Invalid Length",
paste("Filter returned length", length(filter_result),
"but data has", nrow(data), "rows:", filter_condition),
"", "Error")
result <- data
result$.original_row <- seq_len(nrow(data))
return(result)
}
filtered_data <- data[filter_result, , drop = FALSE]
filtered_data$.original_row <- which(filter_result)
return(filtered_data)
}, error = function(e) {
log_issue("Filter", "Parse Error",
paste("Filter condition failed:", filter_condition, "-", conditionMessage(e)),
"", "Warning")
result <- data
result$.original_row <- seq_len(nrow(data))
return(result)
})
}
calc_percentage <- function(numerator, denominator, decimal_places = decimal_places_percent) {
if (is.na(denominator) || denominator == 0) return(NA_real_)
return(round((numerator / denominator) * 100, decimal_places))
}
format_output_value <- function(value, type = "frequency") {
if (is.null(value) || is.na(value)) return(NA_real_)
formatted_value <- switch(type,
"percent" = round(as.numeric(value), decimal_places_percent),
"rating" = round(as.numeric(value), decimal_places_ratings),
"index" = round(as.numeric(value), decimal_places_index),
"frequency" = round(as.numeric(value), 0),
round(as.numeric(value), 2)
)
return(formatted_value)
}
generate_excel_letters <- function(n) {
if (n <= 0) return(character(0))
if (n <= 26) return(LETTERS[1:n])
letters_vec <- character(n)
for (i in 1:n) {
if (i <= 26) {
letters_vec[i] <- LETTERS[i]
} else {
# Generate AA, AB, ..., AZ, BA, BB, ..., ZZ, AAA, ...
prefix_num <- (i - 27) %/% 26 + 1
suffix_num <- (i - 27) %% 26 + 1
letters_vec[i] <- paste0(LETTERS[prefix_num], LETTERS[suffix_num])
}
}
return(letters_vec)
}
z_test_proportions <- function(count1, base1, count2, base2) {
if (base1 < significance_min_base || base2 < significance_min_base) {
return(list(significant = FALSE, p_value = NA, higher = FALSE))
}
if (base1 == 0 || base2 == 0) {
return(list(significant = FALSE, p_value = NA, higher = FALSE))
}
p1 <- count1 / base1
p2 <- count2 / base2
p_pooled <- (count1 + count2) / (base1 + base2)
if (p_pooled == 0 || p_pooled == 1) {
return(list(significant = FALSE, p_value = 1, higher = (p1 > p2)))
}
se <- sqrt(p_pooled * (1 - p_pooled) * (1/base1 + 1/base2))
if (se == 0) return(list(significant = FALSE, p_value = 1, higher = (p1 > p2)))
z_stat <- (p1 - p2) / se
p_value <- 2 * pnorm(-abs(z_stat))
return(list(
significant = (p_value < (1 - significance_level)),
p_value = p_value,
higher = (p1 > p2)
))
}
t_test_means <- function(values1, values2) {
if (length(values1) < significance_min_base || length(values2) < significance_min_base) {
return(list(significant = FALSE, p_value = NA, higher = FALSE))
}
tryCatch({
test_result <- t.test(values1, values2)
return(list(
significant = (test_result$p.value < (1 - significance_level)),
p_value = test_result$p.value,
higher = (mean(values1, na.rm = TRUE) > mean(values2, na.rm = TRUE))
))
}, error = function(e) {
return(list(significant = FALSE, p_value = NA, higher = FALSE))
})
}
run_significance_tests_for_row <- function(row_data, row_type, banner_structure) {
if (is.null(row_data) || length(row_data) == 0) return(list())
if (is.null(banner_structure) || is.null(banner_structure$letters)) return(list())
num_comparisons <- choose(length(row_data), 2)
if (num_comparisons == 0) return(list())
alpha <- 1 - significance_level
if (bonferroni_correction && num_comparisons > 0) {
alpha <- alpha / num_comparisons
}
sig_results <- list()
column_names <- names(row_data)
for (i in seq_along(row_data)) {
higher_than <- character(0)
for (j in seq_along(row_data)) {
if (i == j) next
test_result <- if (row_type %in% c("proportion", "topbox")) {
z_test_proportions(
row_data[[i]]$count, row_data[[i]]$base,
row_data[[j]]$count, row_data[[j]]$base
)
} else if (row_type %in% c("mean", "index")) {
t_test_means(row_data[[i]]$values, row_data[[j]]$values)
} else {
list(significant = FALSE, p_value = NA, higher = FALSE)
}
if (!is.na(test_result$p_value) && test_result$p_value < alpha && test_result$higher) {
col_letter <- banner_structure$letters[banner_structure$column_names == column_names[j]]
if (length(col_letter) > 0) {
higher_than <- c(higher_than, col_letter)
}
}
}
sig_results[[column_names[i]]] <- paste(higher_than, collapse = "")
}
return(sig_results)
}
add_significance_row <- function(test_data, banner_info, row_type, internal_columns) {
if (is.null(test_data) || length(test_data) < 2) return(NULL)
# FIX #1: Use internal keys for sig_values
sig_values <- setNames(rep("", length(internal_columns)), internal_columns)
total_key <- paste0("TOTAL::", TOTAL_COLUMN)
if (total_key %in% names(sig_values)) {
sig_values[total_key] <- "-"
}
for (banner_code in names(banner_info$banner_info)) {
banner_cols <- banner_info$banner_info[[banner_code]]$internal_keys
banner_test_data <- test_data[names(test_data) %in% banner_cols]
if (length(banner_test_data) > 1) {
banner_structure <- list(
column_names = names(banner_test_data),
letters = banner_info$banner_info[[banner_code]]$letters
)
sig_results <- run_significance_tests_for_row(banner_test_data, row_type, banner_structure)
for (col_key in names(sig_results)) {
sig_values[col_key] <- sig_results[[col_key]]
}
}
}
sig_row <- data.frame(RowLabel = "", RowType = SIG_ROW_TYPE, stringsAsFactors = FALSE)
for (col_key in internal_columns) {
sig_row[[col_key]] <- sig_values[col_key]
}
return(sig_row)
}
create_banner_structure <- function() {
banner_questions <- questions_df[questions_df$Use_As_Banner == "Y" &
!is.na(questions_df$Use_As_Banner), ]
if (nrow(banner_questions) == 0) {
# FIX #1: Use internal key for Total
total_internal_key <- paste0("TOTAL::", TOTAL_COLUMN)
return(list(
banner_questions = NULL,
columns = TOTAL_COLUMN,
internal_keys = total_internal_key,
column_labels = TOTAL_COLUMN,
letters = "-",
column_to_banner = setNames(TOTAL_COLUMN, total_internal_key),
key_to_display = setNames(TOTAL_COLUMN, total_internal_key)
))
}
if ("Display_Order" %in% names(banner_questions) && !all(is.na(banner_questions$Display_Order))) {
banner_questions <- banner_questions[order(banner_questions$Display_Order, na.last = TRUE), ]
}
# FIX #1: Track both display names and unique internal keys
all_columns <- TOTAL_COLUMN
all_internal_keys <- paste0("TOTAL::", TOTAL_COLUMN)
all_letters <- "-"
column_to_banner <- setNames(TOTAL_COLUMN, all_internal_keys[1])
key_to_display <- setNames(TOTAL_COLUMN, all_internal_keys[1])
all_banner_info <- list()
banner_headers <- data.frame(
start_col = numeric(), end_col = numeric(), label = character(),
stringsAsFactors = FALSE
)
current_col_index <- 2
for (banner_idx in seq_len(nrow(banner_questions))) {
banner_question_code <- banner_questions$QuestionCode[banner_idx]
banner_options <- options_df[options_df$QuestionCode == banner_question_code &
(options_df$Show_In_Output == "Y" | is.na(options_df$Show_In_Output)), ]
if ("Display_Order" %in% names(banner_options) && !all(is.na(banner_options$Display_Order))) {
banner_options <- banner_options[order(banner_options$Display_Order, na.last = TRUE), ]
}
banner_columns <- banner_options$DisplayText
# FIX #1: Create unique internal keys
banner_internal_keys <- paste0(banner_question_code, "::", banner_columns)
all_columns <- c(all_columns, banner_columns)
all_internal_keys <- c(all_internal_keys, banner_internal_keys)
num_cols <- length(banner_columns)
# FIX #3: Use generate_excel_letters for >26 columns
banner_letters <- generate_excel_letters(num_cols)
all_letters <- c(all_letters, banner_letters)
# FIX #1: Map internal keys to banner and display names
for (i in seq_along(banner_columns)) {
column_to_banner[banner_internal_keys[i]] <- banner_question_code
key_to_display[banner_internal_keys[i]] <- banner_columns[i]
}
banner_label <- if (!is.na(banner_questions$Banner_Label[banner_idx])) {
banner_questions$Banner_Label[banner_idx]
} else {
banner_questions$QuestionText[banner_idx]
}
banner_headers <- rbind(banner_headers, data.frame(
start_col = current_col_index,
end_col = current_col_index + length(banner_columns) - 1,
label = banner_label,
stringsAsFactors = FALSE
))
current_col_index <- current_col_index + length(banner_columns)
all_banner_info[[banner_question_code]] <- list(
question = banner_questions[banner_idx, ],
options = banner_options,
letters = banner_letters,
columns = banner_columns,
internal_keys = banner_internal_keys  # FIX #1: Store internal keys
)
}
return(list(
banner_questions = banner_questions,
banner_info = all_banner_info,
banner_headers = banner_headers,
columns = all_columns,
internal_keys = all_internal_keys,  # FIX #1: Add internal keys
column_labels = all_columns,
letters = all_letters,
column_to_banner = column_to_banner,
key_to_display = key_to_display  # FIX #1: Add key-to-display mapping
))
}
create_banner_data_subsets <- function(data, banner_info) {
# FIX #1: Use internal keys for list names
total_key <- paste0("TOTAL::", TOTAL_COLUMN)
banner_data_list <- setNames(list(data), total_key)
if (!is.null(banner_info$banner_questions)) {
col_index <- 2
for (banner_code in names(banner_info$banner_info)) {
banner_data_info <- banner_info$banner_info[[banner_code]]
banner_col <- banner_data_info$question$QuestionCode
for (option_idx in seq_len(nrow(banner_data_info$options))) {
banner_option_text <- banner_data_info$options$OptionText[option_idx]
banner_subset <- data[safe_equal(data[[banner_col]], banner_option_text) &
!is.na(data[[banner_col]]), , drop = FALSE]
# FIX #1: Use internal key
internal_key <- banner_info$internal_keys[col_index]
banner_data_list[[internal_key]] <- banner_subset
col_index <- col_index + 1
}
}
}
return(banner_data_list)
}
calculate_banner_bases <- function(banner_data_list, internal_keys, question_info) {
bases <- sapply(internal_keys, function(key) {
get_valid_base(banner_data_list[[key]], question_info)
})
return(bases)
}
setwd("/Users/duncan/Documents/Turas")
source("launch_turas.R")
